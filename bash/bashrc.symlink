# GENERAL SETTINGS

# If not running interactively, don't do anything
case $- in
    *i*) ;;
      *) return;;
esac

# Alias definitions
if [ -f ~/.dotfiles/bash/aliases.bash ]; then
  . ~/.dotfiles/bash/aliases.bash
fi

# don't put duplicate lines or lines starting with space in the history
HISTCONTROL="erasedups:ignoreboth"

# Commands that don't need to get recorded
export HISTIGNORE="&:[ ]*:exit:ls:bg:fg:history"

# Save multi-line commands to the history as one command
shopt -s cmdhist

# Append to the history file, don't overwrite it
shopt -s histappend

# Set history size to a very large number
HISTSIZE=500000
HISTFILESIZE=100000

# Record each line of history right away
# instead of at the end of the session
PROMPT_COMMAND='history -a'

# Set history timestamp format
HISTTIMEFORMAT='%F %T '

# Activate and define cdable variables
shopt -s cdable_vars
export dotfiles="$HOME/.dotfiles"
export code="$HOME/code"
export dropbox="$HOME/Dropbox"

# Define search path for the cd command
CDPATH=".:~/code"

# Implicit cd
shopt -s autocd

# Correct minor errors in the spelling of a directory
shopt -s cdspell
shopt -s dirspell

# colors!
GREEN="\[\e[0;32m\]"
BLUE="\[\e[0;34m\]"
RED="\[\e[0;31m\]"
BRED="\e[1;31m\]"
YELLOW="\[\e[0;33m\]"
WHITE="\e[0;37m\]"
BWHITE="\e[1;37m\]"
COLOREND="\[\e[00m\]"

# NVM
export NVM_DIR=~/.nvm
source $(brew --prefix nvm)/nvm.sh

# more PATH adjustments
export PATH=$PATH:$HOME/bin # user bin directory
export PATH="$HOME/.rbenv/bin:$PATH"
export PATH=$PATH:/usr/local/share/python # Python installed scripts

# setup fzf
[ -f ~/.fzf.bash ] && source ~/.fzf.bash

# setup chruby
source /usr/local/share/chruby/chruby.sh
source /usr/local/share/chruby/auto.sh
RUBIES=(~/.rubies/*)
chruby ruby-2.2.3

# homebrew path adjustments
export PATH="$PATH:/usr/local/share/npm/bin" Add NPM to PATH
export PATH="$PATH:/usr/local/sbin"

#BASH Completion - Homebrew
if [[ -z "$BASH_COMPLETION" ]]; then
	export BASH_COMPLETION=/usr/local/etc/bash_completion
fi

if [[ -z "$BASH_COMPLETION_DIR" ]]; then
	export BASH_COMPLETION_DIR=/usr/local/etc/bash_completion.d
fi

if [[ -z "$BASH_COMPLETION_COMPAT_DIR" ]]; then
	export BASH_COMPLETION_COMPAT_DIR=/usr/local/etc/bash_completion.d
fi

if [ -f $BASH_COMPLETION ]; then
. $BASH_COMPLETION
fi

[[ -e "$HOME/.bash_work" ]] && source "$HOME/.bash_work"

# Responsive Prompt
parse_node_version() {
  version=`nvm current | cut -f 2`
  echo "${BLUE}($version)${COLOREND} "
}

parse_git_branch() {
  if [[ -f "$BASH_COMPLETION_DIR/git-completion.bash" ]]; then
    branch=`__git_ps1 "%s"`
  else
    ref=$(git-symbolic-ref HEAD 2> /dev/null) || return
    branch="${ref#refs/heads/}"
  fi

  if [[ `tput cols` -lt 110 ]]; then
    branch=`echo $branch | sed s/feature/f/1`
    branch=`echo $branch | sed s/hotfix/h/1`
    branch=`echo $branch | sed s/release/\r/1`

    branch=`echo $branch | sed s/master/mstr/1`
    branch=`echo $branch | sed s/develop/dev/1`
  fi

  if [[ $branch != "" ]]; then
    if [[ $(git status 2> /dev/null | tail -n1) == "nothing to commit, working directory clean" ]]; then
      echo "${GREEN}$branch${COLOREND} "
    else
      echo "${RED}$branch${COLROEND} "
    fi
  fi
}

working_directory() {
  dir=`pwd`
  in_home=0
  if [[ `pwd` =~ ^"$HOME"(/|$) ]]; then
    dir="~${dir#$HOME}"
    in_home=1
  fi

  workingdir=""
  if [[ `tput cols` -lt 110 ]]; then
    first="/`echo $dir | cut -d / -f 2`"
    letter=${first:0:2}
    if [[ $in_home == 1 ]]; then
      letter="~$letter"
    fi
    proj=`echo $dir | cut -d / -f 3`
    beginning="$letter/$proj"
    end=`echo "$dir" | rev | cut -d / -f1 | rev`

    if [[ $proj == "" ]]; then
      workingdir="$dir"
    elif [[ $proj == "~" ]]; then
      workingdir="$dir"
    elif [[ $dir =~ "$first/$proj"$ ]]; then
      workingdir="$beginning"
    elif [[ $dir =~ "$first/$proj/$end"$ ]]; then
      workingdir="$beginning/$end"
    else
      workingdir="$beginning/…/$end"
    fi
  else
    workingdir="$dir"
  fi

  echo -e "${YELLOW}$workingdir${COLOREND} "
}

parse_remote_state() {
  remote_state=$(git status -sb 2> /dev/null | grep -oh "\[.*\]")
  if [[ "$remote_state" != "" ]]; then
    out="${BLUE}[${COLOREND}"

    if [[ "$remote_state" == *ahead* ]] && [[ "$remote_state" == *behind* ]]; then
      behind_num=$(echo "$remote_state" | grep -oh "behind \d*" | grep -oh "\d*$")
      ahead_num=$(echo "$remote_state" | grep -oh "ahead \d*" | grep -oh "\d*$")
      out="$out${RED}$behind_num${COLOREND},${GREEN}$ahead_num${COLOREND}"
    elif [[ "$remote_state" == *ahead* ]]; then
      ahead_num=$(echo "$remote_state" | grep -oh "ahead \d*" | grep -oh "\d*$")
      out="$out${GREEN}$ahead_num${COLOREND}"
    elif [[ "$remote_state" == *behind* ]]; then
      behind_num=$(echo "$remote_state" | grep -oh "behind \d*" | grep -oh "\d*$")
      out="$out${RED}$behind_num${COLOREND}"
    fi

    out="$out${BLUE}]${COLOREND}"
    echo "$out "
  fi
}

prompt() {
  if [[ $? -eq 0 ]]; then
    exit_status="${BLUE}▸${COLOREND} "
  else
    exit_status="${RED}▸${COLOREND} "
  fi

  PS1="$(working_directory)$(parse_git_branch)$(parse_remote_state)${COLOREND} $exit_status"
}

PROMPT_COMMAND=prompt
# Git custom prompt
# export GITAWAREPROMPT=~/bin/git-aware-prompt
# source "${GITAWAREPROMPT}/main.sh"
# export PS1="\[\033[33;1m\]\W\[\033[m\]\[$txtcyn\]\$git_branch\[$txtred\]\$git_dirty\[$txtrst\]$ "

# Complete all the things
# source ~/bin/git-completion.bash
# source ~/bin/tmux.completion.bash
# source ~/bin/tmuxinator.bash
# source ~/bin/npm-completion.bash
# source ~/bin/pandoc.bash

# add node bin folder to PATH
export PATH="$HOME/.node/bin:$PATH"

# Add my bin folder to PATH
export PATH="$HOME/bin:$PATH"

# Set Vim as default editor
export EDITOR="nvim"

if [[ "$OSTYPE" == "darwin"* ]]; then

  # OSX-SPECIFIC SETTINGS

  # enable programmable completion
  if [ -f $(brew --prefix)/etc/bash_completion ]; then
    . $(brew --prefix)/etc/bash_completion
  fi

  # activates colors
  export CLICOLOR=1

  # ls custom colors
  export LSCOLORS=ExFxBxDxCxegedabagacad

  # Fix Python error 'unknown locale: UTF-8'
  export LC_ALL=en_US.UTF-8
  export LANG=en_US.UTF-8

  # Base16 Shell
  BASE16_SHELL="/Users/zool/.config/base16-shell/base16-ocean.dark.sh"
  [[ -s $BASE16_SHELL ]] && source $BASE16_SHELL

  # add homebrew bin folder to PATH
  export PATH="/usr/local/bin:$PATH"

  # Fix LaTeX after El Capitan update
  export PATH="$PATH:/Library/TeX/Distributions/.DefaultTeX/Contents/Programs/texbin"

  # Add Calibre command line tools
  export PATH=$PATH:/Applications/calibre.app/Contents/MacOS

  # Add Miniconda2
  export PATH="/Users/zool/tools/miniconda2/bin:$PATH"

elif [[ "$OSTYPE" == "linux-gnu" ]]; then

  # LINUX-SPECIFIC SETTINGS

  # set variable identifying the chroot you work in
  if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
  fi

  # set a fancy prompt (non-color, unless we know we "want" color)
  case "$TERM" in
    xterm-color) color_prompt=yes;;
  esac

  # uncomment for a colored prompt, if the terminal has the capability
  force_color_prompt=yes

  if [ -n "$force_color_prompt" ]; then
    if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
      # We have color support; assume it's compliant with Ecma-48
      # (ISO/IEC-6429). (Lack of such support is extremely rare, and such
      # a case would tend to support setf rather than setaf.)
      color_prompt=yes
    else
      color_prompt=
    fi
  fi

  if [ "$color_prompt" = yes ]; then
    PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\W\[\033[00m\]\$ '
  else
    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\W\$ '
  fi
  unset color_prompt force_color_prompt

  # If this is an xterm set the title to user@host:dir
  case "$TERM" in
    xterm*|rxvt*)
      PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \W\a\]$PS1"
      ;;
    *)
      ;;
  esac

  # enable color support of ls and also add handy aliases
  if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    alias dir='dir --color=auto'
    alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
  fi

  # enable programmable completion features
  if ! shopt -oq posix; then
    if [ -f /usr/share/bash-completion/bash_completion ]; then
      . /usr/share/bash-completion/bash_completion
    elif [ -f /etc/bash_completion ]; then
      . /etc/bash_completion
    fi
  fi

  # Add RVM to PATH for scripting
  export PATH="$PATH:$HOME/.rvm/bin"

fi
